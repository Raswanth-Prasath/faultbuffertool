# -*- coding: utf-8 -*-
"""
/***************************************************************************
 FaultBufferTool
                                 A QGIS plugin
 This plugin will create buffers based on the provided lookup table and attributes in the input shapefile.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-02-01
        git sha              : $Format:%H$
        copyright            : (C) 2025 by ASU
        email                : raswanth@asu.edu
 ***************************************************************************/

 ***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QVariant
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QMessageBox, QFileDialog, QPushButton
from qgis import processing

from qgis.core import (
    QgsProject,
    QgsVectorLayer,
    QgsField,
    QgsFeature,
    QgsProcessingContext,
    QgsProcessingFeedback,
    QgsVectorFileWriter,
    QgsSymbol,
    QgsRendererCategory,
    QgsCategorizedSymbolRenderer,
    QgsMessageLog,
    QgsCoordinateReferenceSystem,
    QgsCoordinateTransform,
    QgsDistanceArea,
    QgsPointXY,
    QgsGeometry
)
from qgis.gui import QgsFileWidget

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .FaultBufferTool_dialog import FaultBufferToolDialog
import os.path


class FaultBufferTool:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'FaultBufferTool_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&FaultBufferTool')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None
        self.dlg = None
        self.buffer_distances = { # This seems unused, but left it here from previous code
            ('P', 1): 200,
            ('P', 2): 80,
            ('P', 3): 30,
            ('P', 4): 10,
            ('S', 1): 300,
            ('S', 2): 100,
            ('S', 3): 70,
            ('S', 4): 20
        }

        # Uncertainty table for different criteria - UPDATED based on the provided text
        self.uncertainty_table = {
            # General uncertainty for a predicted rupture
            'general': {
                '50th': 20,
                '84th': 60,
                '97th': 130
            },
            # Use one: Fault confidence
            'confidence': {
                'strong': {'50th': 10, '84th': 25, '97th': 50},
                'distinct': {'50th': 15, '84th': 40, '97th': 60},
                'weak': {'50th': 25, '84th': 55, '97th': 105},
                'uncertain': {'50th': 45, '84th': 120, '97th': 260}
            },
            # Use one: Primary versus Secondary
            'primary_secondary': {
                'primary': {'50th': 20, '84th': 60, '97th': 130},
                'secondary': {'50th': 20, '84th': 60, '97th': 110}
            },
            # Use one: Simple versus complex
            'simple_complex': {
                'simple': {'50th': 20, '84th': 60, '97th': 130},
                'complex': {'50th': 20, '84th': 60, '97th': 100} # Corrected 'Compex' typo
            },
            # Use two: Conf & Prim/Sec
            'conf_prim_sec': {
                'strong_primary': {'50th': 10, '84th': 25, '97th': 35},
                'distinct_primary': {'50th': 15, '84th': 35, '97th': 60},
                'weak_primary': {'50th': 25, '84th': 50, '97th': 105},
                'uncertain_primary': {'50th': 50, '84th': 120, '97th': 228},
                'strong_secondary': {'50th': 15, '84th': 35, '97th': 69},
                'distinct_secondary': {'50th': 20, '84th': 45, '97th': 60},
                'weak_secondary': {'50th': 25, '84th': 70, '97th': 115},
                'uncertain_secondary': {'50th': 25, '84th': 70, '97th': 480}
            },
            # Use two: Conf & Simp/Comp
            'conf_simple_complex': {
                'strong_simple': {'50th': 10, '84th': 25, '97th': 40},
                'distinct_simple': {'50th': 15, '84th': 40, '97th': 60},
                'weak_simple': {'50th': 25, '84th': 50, '97th': 105},
                'uncertain_simple': {'50th': 50, '84th': 125, '97th': 250},
                'strong_complex': {'50th': 10, '84th': 35, '97th': 55},
                'distinct_complex': {'50th': 10, '84th': 35, '97th': 55},
                'weak_complex': {'50th': 25, '84th': 70, '97th': 100},
                'uncertain_complex': {'50th': 35, '84th': 70, '97th': 430}
            },
            # Use two: Prim/Sec & Simp/Comp
            'prim_sec_simple_complex': {
                'primary_simple': {'50th': 20, '84th': 65, '97th': 135},
                'primary_complex': {'50th': 20, '84th': 50, '97th': 65},
                'secondary_simple': {'50th': 20, '84th': 45, '97th': 63},
                'secondary_complex': {'50th': 20, '84th': 65, '97th': 175}
            },
            # Use all three: Conf, Prim/Sec & Simp/Comp
            'all_criteria': {
                'strong_primary_simple': {'50th': 10, '84th': 25, '97th': 40},
                'distinct_primary_simple': {'50th': 15, '84th': 35, '97th': 60},
                'weak_primary_simple': {'50th': 25, '84th': 50, '97th': 105},
                'uncertain_primary_simple': {'50th': 50, '84th': 130, '97th': 255},
                'strong_secondary_simple': {'50th': 10, '84th': 15, '97th': 15},
                'distinct_secondary_simple': {'50th': 30, '84th': 50, '97th': 60},
                'weak_secondary_simple': {'50th': 45, '84th': 100, '97th': 160},
                'uncertain_secondary_simple': {'50th': 45, '84th': 100, '97th': 160},
                'strong_primary_complex': {'50th': 10, '84th': 15, '97th': 20},
                'distinct_primary_complex': {'50th': 10, '84th': 30, '97th': 35},
                'weak_primary_complex': {'50th': 30, '84th': 50, '97th': 90},
                'uncertain_primary_complex': {'50th': 40, '84th': 60, '97th': 90},
                'strong_secondary_complex': {'50th': 20, '84th': 41, '97th': 90},
                'distinct_secondary_complex': {'50th': 20, '84th': 35, '97th': 90},
                'weak_secondary_complex': {'50th': 25, '84th': 70, '97th': 100},
                'uncertain_secondary_complex': {'50th': 25, '84th': 118, '97th': 500}
            },
            # For unpredicted ruptures
            'unpredicted': { # This seems unused based on current UI, but left it here
                '50th': 300,
                '84th': 1000,
                '97th': 1700
            }
        }

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('FaultBufferTool', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/FaultBufferTool/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Fault Buffer Tool'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&FaultBufferTool'),
                action)
            self.iface.removeToolBarIcon(action)

    def get_utm_crs(self, longitude, latitude):
        """Calculate the appropriate UTM CRS based on coordinates"""
        # Calculate UTM zone
        zone = int((longitude + 180) / 6) + 1

        # Determine if Northern or Southern hemisphere
        if latitude > 0:
            epsg = f"326{zone:02d}"  # Northern hemisphere
        else:
            epsg = f"327{zone:02d}"  # Southern hemisphere

        return QgsCoordinateReferenceSystem(f"EPSG:{epsg}")

    def create_asymmetric_buffer(self, geometry, distance, dip_direction, input_crs, segments, buffer_ratio):
        """
        Creates an asymmetric buffer by:
        1. Translating the fault line based on dip direction
        2. Using QGIS's built-in buffer function
        """
        try:
            from qgis.core import QgsFeature, QgsGeometry, QgsVectorLayer, QgsWkbTypes

            # Log initial parameters
            # QgsMessageLog.logMessage(f"Starting asymmetric buffer creation: distance={distance}, dip={dip_direction}, ratio={buffer_ratio}", "FaultBufferTool")
            # QgsMessageLog.logMessage(f"Input CRS for asymmetric buffer: {input_crs.authid()}", "FaultBufferTool")

            # Calculate translation based on buffer ratio
            # translation_dist = distance * ((1-buffer_ratio)/(1+buffer_ratio)) # Original calculation - might be too complex if buffer() handles width correctly?
            # Let's recalculate translation based on shifting the *centerline*
            # Total width = 2 * distance. HW side = distance * (2 * buffer_ratio / (1+buffer_ratio)), FW side = distance * (2 * 1 / (1+buffer_ratio))
            # Centerline shift = (FW_side - HW_side) / 2 = distance * (1 - buffer_ratio) / (1 + buffer_ratio)
            translation_dist = distance * (1 - buffer_ratio) / (1 + buffer_ratio)


            # Calculate diagonal distance for NE, NW, SE, SW directions
            diagonal_dist = translation_dist / (2 ** 0.5) # sqrt(2)

            # Calculate translation offsets based on dip direction (shifting *towards* the hanging wall)
            # Example: Normal fault (FW:HW = 1:4), buffer_ratio=4. Shift = dist*(1-4)/(1+4) = -3/5*dist. Needs to shift AWAY from dip direction.
            # Example: Reverse fault (FW:HW = 1:2), buffer_ratio=2. Shift = dist*(1-2)/(1+2) = -1/3*dist. Needs to shift AWAY from dip direction.
            # So, we negate the translation distance calculation here.
            translation_dist = -translation_dist

            if dip_direction.upper() == 'N':
                dx, dy = 0, translation_dist
            elif dip_direction.upper() == 'S':
                dx, dy = 0, -translation_dist
            elif dip_direction.upper() == 'E':
                dx, dy = translation_dist, 0
            elif dip_direction.upper() == 'W':
                dx, dy = -translation_dist, 0
            elif dip_direction.upper() == 'NE':
                dx, dy = translation_dist / (2**0.5), translation_dist / (2**0.5)
            elif dip_direction.upper() == 'NW':
                dx, dy = -translation_dist / (2**0.5), translation_dist / (2**0.5)
            elif dip_direction.upper() == 'SE':
                dx, dy = translation_dist / (2**0.5), -translation_dist / (2**0.5)
            elif dip_direction.upper() == 'SW':
                dx, dy = -translation_dist / (2**0.5), -translation_dist / (2**0.5)
            else:
                QgsMessageLog.logMessage(f"Invalid dip direction: {dip_direction}. Defaulting to East.", "FaultBufferTool")
                dx, dy = translation_dist, 0  # Default to East if invalid

            QgsMessageLog.logMessage(f"Calculated translation: dx={dx}, dy={dy} for dip={dip_direction}, dist={distance}, ratio={buffer_ratio}", "FaultBufferTool")

            # Clone the original geometry to avoid modifying it
            translated_geom = QgsGeometry(geometry)
            # Translate the geometry
            translated_geom.translate(dx, dy)

            if not translated_geom or translated_geom.isEmpty():
                 QgsMessageLog.logMessage(f"Translation resulted in empty geometry. dx={dx}, dy={dy}", "FaultBufferTool")
                 return None

            QgsMessageLog.logMessage("Creating buffer on translated geometry...", "FaultBufferTool")

            # Create buffer using the *original* distance on the *translated* geometry
            buffer_geom = translated_geom.buffer(distance, segments)

            if not buffer_geom or buffer_geom.isEmpty() or not buffer_geom.isGeosValid():
                QgsMessageLog.logMessage(f"Failed to create valid buffer geometry after translation. Buffer distance: {distance}", "FaultBufferTool")
                return None

            QgsMessageLog.logMessage(f"Asymmetric buffer created successfully. Type: {buffer_geom.wkbType()}", "FaultBufferTool")
            return buffer_geom

        except Exception as e:
            QgsMessageLog.logMessage(f"Error in create_asymmetric_buffer: {str(e)}", "FaultBufferTool")
            import traceback
            QgsMessageLog.logMessage(f"Traceback: {traceback.format_exc()}", "FaultBufferTool")
            return None

    def get_uncertainty_distance(self, feature):
        """
        Get buffer distance based on uncertainty rankings selected in the UI
        Only uses fields corresponding to checked boxes
        """
        # Determine selected percentile (default to 50th if none/invalid)
        percentile = '50th' # Default
        if self.dlg.percentile84RadioButton.isChecked():
            percentile = '84th'
        elif self.dlg.percentile97RadioButton.isChecked():
            percentile = '97th'

        # General uncertainty (ignore rankings) - This takes precedence if selected
        if self.dlg.generalUncertaintyRadioButton.isChecked():
            return self.uncertainty_table['general'].get(percentile, 0) # Use .get for safety

        # If not general uncertainty, proceed with ranking (only if uncertaintyWithRankingRadioButton is checked)
        if not self.dlg.uncertaintyWithRankingRadioButton.isChecked():
             QgsMessageLog.logMessage("Warning: get_uncertainty_distance called but ranking not selected. Returning 0.", "FaultBufferTool")
             return 0 # Should not happen if UI logic is correct, but safe fallback

        available_fields = [f.name().lower() for f in feature.fields()] # Use lower case for robustness

        # Initialize variables with defaults or None if not checked
        confidence_text = None
        primary_secondary = None
        simple_complex = None

        # Check if ranking criteria checkboxes are checked and fields exist
        conf_selected = self.dlg.confidenceCheckBox.isChecked() and 'quality' in available_fields
        prim_sec_selected = self.dlg.primarySecondaryCheckBox.isChecked() and 'p or s' in available_fields
        simple_complex_selected = self.dlg.simpleComplexCheckBox.isChecked() and 'simpcomp' in available_fields

        # --- Get values based on selected criteria ---
        if conf_selected:
            confidence = feature['Quality'] # Assuming original case name 'Quality'
            # Handle potential NULL or unexpected types
            if confidence == 4: confidence_text = 'strong'
            elif confidence == 3: confidence_text = 'distinct'
            elif confidence == 2: confidence_text = 'weak'
            elif confidence == 1: confidence_text = 'uncertain'
            else: confidence_text = 'uncertain' # Default for unexpected values

        if prim_sec_selected:
            p_or_s_val = feature["P or S"] # Assuming original case name 'P or S'
            # Handle potential NULL or unexpected types
            if isinstance(p_or_s_val, str):
                p_or_s = p_or_s_val.strip().upper()
                primary_secondary = 'primary' if p_or_s == 'P' else 'secondary'
            else:
                primary_secondary = 'primary' # Default if value is missing/invalid

        if simple_complex_selected:
            simp_comp_val = feature['SimpComp'] # Assuming original case name 'SimpComp'
             # Handle potential NULL or unexpected types
            if isinstance(simp_comp_val, str):
                simp_comp = simp_comp_val.strip().upper()
                simple_complex = 'complex' if simp_comp == 'C' else 'simple'
            else:
                simple_complex = 'simple' # Default if value is missing/invalid

        # --- Determine which table section to use ---
        num_selected = sum([conf_selected, prim_sec_selected, simple_complex_selected])
        distance = 0 # Default distance

        try:
            if num_selected == 3:
                key = f"{confidence_text}_{primary_secondary}_{simple_complex}"
                distance = self.uncertainty_table['all_criteria'].get(key, {}).get(percentile, 0)
                QgsMessageLog.logMessage(f"Using all_criteria: key='{key}', percentile='{percentile}', dist={distance}", "FaultBufferTool")
            elif num_selected == 2:
                if conf_selected and prim_sec_selected:
                    key = f"{confidence_text}_{primary_secondary}"
                    distance = self.uncertainty_table['conf_prim_sec'].get(key, {}).get(percentile, 0)
                    QgsMessageLog.logMessage(f"Using conf_prim_sec: key='{key}', percentile='{percentile}', dist={distance}", "FaultBufferTool")
                elif conf_selected and simple_complex_selected:
                    key = f"{confidence_text}_{simple_complex}"
                    distance = self.uncertainty_table['conf_simple_complex'].get(key, {}).get(percentile, 0)
                    QgsMessageLog.logMessage(f"Using conf_simple_complex: key='{key}', percentile='{percentile}', dist={distance}", "FaultBufferTool")
                elif prim_sec_selected and simple_complex_selected:
                    key = f"{primary_secondary}_{simple_complex}"
                    distance = self.uncertainty_table['prim_sec_simple_complex'].get(key, {}).get(percentile, 0)
                    QgsMessageLog.logMessage(f"Using prim_sec_simple_complex: key='{key}', percentile='{percentile}', dist={distance}", "FaultBufferTool")
            elif num_selected == 1:
                if conf_selected:
                    distance = self.uncertainty_table['confidence'].get(confidence_text, {}).get(percentile, 0)
                    QgsMessageLog.logMessage(f"Using confidence: key='{confidence_text}', percentile='{percentile}', dist={distance}", "FaultBufferTool")
                elif prim_sec_selected:
                    distance = self.uncertainty_table['primary_secondary'].get(primary_secondary, {}).get(percentile, 0)
                    QgsMessageLog.logMessage(f"Using primary_secondary: key='{primary_secondary}', percentile='{percentile}', dist={distance}", "FaultBufferTool")
                elif simple_complex_selected:
                    distance = self.uncertainty_table['simple_complex'].get(simple_complex, {}).get(percentile, 0)
                    QgsMessageLog.logMessage(f"Using simple_complex: key='{simple_complex}', percentile='{percentile}', dist={distance}", "FaultBufferTool")

            # Fallback if no criteria were selected (should not happen if UI logic prevents this)
            # Or if the specific combination wasn't found in the tables
            if num_selected == 0 or distance == 0:
                 QgsMessageLog.logMessage(f"Warning: No matching uncertainty criteria found or num_selected=0. Falling back to general uncertainty. Num selected={num_selected}", "FaultBufferTool")
                 distance = self.uncertainty_table['general'].get(percentile, 0) # Fallback safely

        except KeyError as e:
             QgsMessageLog.logMessage(f"KeyError accessing uncertainty table: {e}. Falling back to general uncertainty.", "FaultBufferTool")
             distance = self.uncertainty_table['general'].get(percentile, 0) # Fallback safely
        except Exception as e:
             QgsMessageLog.logMessage(f"Error in get_uncertainty_distance lookup: {e}. Falling back to general uncertainty.", "FaultBufferTool")
             distance = self.uncertainty_table['general'].get(percentile, 0) # Fallback safely


        return distance

    def validate_required_fields(self, input_layer):
        """
        Validates that the input layer has required fields based on selected options
        Checks for fields based on UI selections at the time of validation.
        Uses case-insensitive field name checking.
        """
        available_fields_lower = [f.name().lower() for f in input_layer.fields()]
        QgsMessageLog.logMessage(f"Available fields (lowercase): {available_fields_lower}", "FaultBufferTool")

        # --- Geologic Judgment ---
        if self.dlg.geologicJudgementRadioButton.isChecked():
            # Check for geo_unc if reading from shapefile
            if self.dlg.fromShapefile.isChecked() and 'geo_unc' not in available_fields_lower:
                return False, "Field 'geo_unc' is required when 'From shapefile' is selected under Geologic Judgment."

            # Check for Dip_direct if *any* non-strike-slip option is possible (uniform or shapefile)
            # Needs Dip_direct if Normal or Reverse is chosen *uniformly* OR if reading from shapefile (as N/R might exist)
            needs_dip_geo = (self.dlg.NormalFaultRadioButton.isChecked() or
                             self.dlg.ReverseFaultRadioButton.isChecked() or
                             self.dlg.FromShapefileFaultTypeRadioButton.isChecked())

            if needs_dip_geo and 'dip_direct' not in available_fields_lower:
                 # Clarify message based on selection
                 if self.dlg.FromShapefileFaultTypeRadioButton.isChecked():
                     return False, "Field 'Dip_direct' is required when reading fault type from shapefile (may contain Normal/Reverse faults)."
                 else:
                     return False, "Field 'Dip_direct' is required for uniformly selected Normal/Reverse faults under Geologic Judgment."
            return True, "" # Geologic judgment validation passed

        # --- Uncertainty with Ranking ---
        elif self.dlg.uncertaintyWithRankingRadioButton.isChecked():
            # Check selected ranking fields
            if self.dlg.confidenceCheckBox.isChecked() and 'quality' not in available_fields_lower:
                return False, "Field 'Quality' is required when 'Fault Confidence' ranking is checked."
            if self.dlg.primarySecondaryCheckBox.isChecked() and 'p or s' not in available_fields_lower:
                 return False, "Field 'P or S' is required when 'Primary versus Secondary' ranking is checked."
            if self.dlg.simpleComplexCheckBox.isChecked() and 'simpcomp' not in available_fields_lower:
                 return False, "Field 'SimpComp' is required when 'Simple versus complex' ranking is checked."

             # Check for Dip_direct if *any* non-strike-slip option is possible (uniform or shapefile)
            needs_dip_unc = (self.dlg.NormalFaultRadioButton.isChecked() or
                             self.dlg.ReverseFaultRadioButton.isChecked() or
                             self.dlg.FromShapefileFaultTypeRadioButton.isChecked())

            if needs_dip_unc and 'dip_direct' not in available_fields_lower:
                # Clarify message based on selection
                if self.dlg.FromShapefileFaultTypeRadioButton.isChecked():
                    return False, "Field 'Dip_direct' is required when reading fault type from shapefile (may contain Normal/Reverse faults)."
                else:
                    return False, "Field 'Dip_direct' is required for uniformly selected Normal/Reverse faults with Uncertainty Ranking."
            return True, "" # Uncertainty ranking validation passed

        # --- General Uncertainty ---
        elif self.dlg.generalUncertaintyRadioButton.isChecked():
             # Check for Dip_direct if *any* non-strike-slip option is possible (uniform or shapefile)
            needs_dip_gen = (self.dlg.NormalFaultRadioButton.isChecked() or
                             self.dlg.ReverseFaultRadioButton.isChecked() or
                             self.dlg.FromShapefileFaultTypeRadioButton.isChecked())

            if needs_dip_gen and 'dip_direct' not in available_fields_lower:
                 # Clarify message based on selection
                 if self.dlg.FromShapefileFaultTypeRadioButton.isChecked():
                     return False, "Field 'Dip_direct' is required when reading fault type from shapefile (may contain Normal/Reverse faults)."
                 else:
                     return False, "Field 'Dip_direct' is required for uniformly selected Normal/Reverse faults with General Uncertainty."
            return True, "" # General uncertainty validation passed

        # Should not reach here if one of the main radio buttons is checked
        return False, "No uncertainty/judgment mode selected."


    # --- UI State Management ---

    def setupDialogConnections(self):
        """Set up signal connections for UI controls"""
        # Connect main uncertainty mode radio buttons
        self.dlg.geologicJudgementRadioButton.toggled.connect(self.update_ui_state)
        self.dlg.generalUncertaintyRadioButton.toggled.connect(self.update_ui_state)
        self.dlg.uncertaintyWithRankingRadioButton.toggled.connect(self.update_ui_state)

        # Connect geologic judgment sub-options
        self.dlg.fromShapefile.toggled.connect(self.update_ui_state) # Use main updater
        self.dlg.inputWidth.toggled.connect(self.update_ui_state) # Use main updater

        # Connect fault type mode radio buttons
        self.dlg.UniformFaultTypeRadioButton.toggled.connect(self.update_ui_state)
        self.dlg.FromShapefileFaultTypeRadioButton.toggled.connect(self.update_ui_state)


    def update_ui_state(self):
        """Updates the enabled/disabled state of UI elements based on selections."""
        if not self.dlg: return

        is_geologic = self.dlg.geologicJudgementRadioButton.isChecked()
        is_general = self.dlg.generalUncertaintyRadioButton.isChecked()
        is_ranking = self.dlg.uncertaintyWithRankingRadioButton.isChecked()
        is_uniform_fault = self.dlg.UniformFaultTypeRadioButton.isChecked()
        # is_shapefile_fault = self.dlg.FromShapefileFaultTypeRadioButton.isChecked() # Not directly needed below


        # --- Geologic Judgment Section ---
        self.dlg.fromShapefile.setEnabled(is_geologic)
        self.dlg.inputWidth.setEnabled(is_geologic)
        self.dlg.widthinput.setEnabled(is_geologic and self.dlg.inputWidth.isChecked())
        self.dlg.feet.setEnabled(is_geologic)
        self.dlg.meters.setEnabled(is_geologic)
        # Set defaults within geologic mode if needed
        if is_geologic:
            if not (self.dlg.fromShapefile.isChecked() or self.dlg.inputWidth.isChecked()):
                self.dlg.inputWidth.setChecked(True)
            if not (self.dlg.feet.isChecked() or self.dlg.meters.isChecked()):
                self.dlg.meters.setChecked(True)
        else:
            # Uncheck sub-options if geologic mode is disabled (optional, but cleaner)
            # self.dlg.fromShapefile.setChecked(False)
            # self.dlg.inputWidth.setChecked(False)
            # self.dlg.widthinput.clear()
            # self.dlg.feet.setChecked(False)
            # self.dlg.meters.setChecked(False)
            pass # Let user selections persist but be disabled


        # --- Uncertainty Ranking Checkboxes ---
        self.dlg.confidenceCheckBox.setEnabled(is_ranking)
        self.dlg.primarySecondaryCheckBox.setEnabled(is_ranking)
        self.dlg.simpleComplexCheckBox.setEnabled(is_ranking)
        # Uncheck if ranking mode is disabled
        if not is_ranking:
            self.dlg.confidenceCheckBox.setChecked(False)
            self.dlg.primarySecondaryCheckBox.setChecked(False)
            self.dlg.simpleComplexCheckBox.setChecked(False)


        # --- Percentile Radio Buttons ---
        enable_percentiles = is_general or is_ranking
        self.dlg.percentile50RadioButton.setEnabled(enable_percentiles)
        self.dlg.percentile84RadioButton.setEnabled(enable_percentiles)
        self.dlg.percentile97RadioButton.setEnabled(enable_percentiles)
        # Ensure one is checked if enabled, else uncheck
        if enable_percentiles:
            if not (self.dlg.percentile50RadioButton.isChecked() or
                    self.dlg.percentile84RadioButton.isChecked() or
                    self.dlg.percentile97RadioButton.isChecked()):
                self.dlg.percentile50RadioButton.setChecked(True)
        else:
            # Auto-exclusive group handles unchecking others, but let's ensure the state is clean if needed
            # self.dlg.percentile50RadioButton.setChecked(False) # Might fight auto-exclusivity
             pass


        # --- Fault Type Specific Radio Buttons ---
        # Enabled only if UniformFaultTypeRadioButton is checked
        self.dlg.StrikeslipFaultRadioButton.setEnabled(is_uniform_fault)
        self.dlg.NormalFaultRadioButton.setEnabled(is_uniform_fault)
        self.dlg.ReverseFaultRadioButton.setEnabled(is_uniform_fault)
        # Ensure one is checked if Uniform is active
        if is_uniform_fault:
            if not (self.dlg.StrikeslipFaultRadioButton.isChecked() or
                    self.dlg.NormalFaultRadioButton.isChecked() or
                    self.dlg.ReverseFaultRadioButton.isChecked()):
                 self.dlg.StrikeslipFaultRadioButton.setChecked(True) # Default to Strike-slip
        # else: # If not uniform, let selections persist but be disabled
             # pass # No need to uncheck, just disable


    def get_buffer_distance_for_feature(self, feature):
        """Get buffer distance based on geologic judgment settings"""
        if not self.dlg.geologicJudgementRadioButton.isChecked():
            return 0 # Should not be called in this mode

        # Get conversion factor based on units (default to meters)
        conversion_factor = 1.0
        if self.dlg.feet.isChecked():
            conversion_factor = 0.3048 # Feet to meters

        if self.dlg.fromShapefile.isChecked():
            # Use attribute from shapefile
            available_fields_lower = [f.name().lower() for f in feature.fields()]
            if 'geo_unc' in available_fields_lower:
                buffer_distance_val = feature['geo_unc'] # Assuming original name 'geo_unc'
                # Make sure it's a valid positive number
                if buffer_distance_val is not None and isinstance(buffer_distance_val, (int, float)) and buffer_distance_val > 0:
                    return buffer_distance_val * conversion_factor
                else:
                    QgsMessageLog.logMessage(f"Invalid or non-positive 'geo_unc' value: {buffer_distance_val} for feature {feature.id()}. Skipping.", "FaultBufferTool")
                    return 0 # Return 0 to indicate skipping
            else:
                # This should have been caught by validate_required_fields, but double-check
                QgsMessageLog.logMessage(f"Feature {feature.id()} missing 'geo_unc' attribute required for 'From shapefile' geologic judgment. Skipping.", "FaultBufferTool")
                return 0 # Return 0 to indicate skipping
        elif self.dlg.inputWidth.isChecked():
            # Use user input (already validated in run method)
            try:
                buffer_distance = float(self.dlg.widthinput.text())
                if buffer_distance > 0:
                    return buffer_distance * conversion_factor
                else:
                     QgsMessageLog.logMessage(f"User input width '{self.dlg.widthinput.text()}' is not positive. Skipping features for uniform width.", "FaultBufferTool")
                     return 0 # Return 0 if width is not positive
            except ValueError:
                 QgsMessageLog.logMessage(f"Invalid user input width '{self.dlg.widthinput.text()}'. Skipping features for uniform width.", "FaultBufferTool")
                 return 0 # Return 0 if input is invalid
        else:
            # Neither 'From shapefile' nor 'Input width' selected (shouldn't happen with UI logic)
            return 0

    def create_buffer_for_feature(self, feature, buffer_layer, distance, input_layer, transform=None,
                        utm_crs=None, source_crs=None):
        """
        Creates a buffer for a single feature with appropriate attributes and geometry handling.

        Args:
            feature: The input QgsFeature to buffer.
            buffer_layer: The target memory QgsVectorLayer for the buffer output.
            distance (float): The buffer distance (radius) in the units of utm_crs. Must be > 0.
            input_layer: The original input QgsVectorLayer (for field reference).
            transform (QgsCoordinateTransform, optional): Transform from source_crs to utm_crs.
            utm_crs (QgsCoordinateReferenceSystem, optional): The projected CRS for buffering.
            source_crs (QgsCoordinateReferenceSystem, optional): The original CRS of the input layer.

        Returns:
            bool: True if the buffer was created and added successfully, False otherwise.
        """
        try:
            fid = feature.id()
            if distance <= 0:
                 QgsMessageLog.logMessage(f"Feature {fid}: Skipping buffer creation due to non-positive distance ({distance}).", "FaultBufferTool")
                 return False

            # Get geometry and transform if needed
            geometry = QgsGeometry(feature.geometry()) # Work on a copy
            if transform and utm_crs and source_crs and geometry:
                # QgsMessageLog.logMessage(f"Transforming geometry for feature {fid} from {source_crs.authid()} to {utm_crs.authid()}", "FaultBufferTool")
                if not geometry.transform(transform):
                     QgsMessageLog.logMessage(f"Feature {fid}: Geometry transformation failed. Skipping.", "FaultBufferTool")
                     return False
            elif not utm_crs:
                 QgsMessageLog.logMessage(f"Feature {fid}: Missing UTM CRS for buffering. Skipping.", "FaultBufferTool")
                 return False

            if not geometry or geometry.isEmpty():
                 QgsMessageLog.logMessage(f"Feature {fid}: Geometry is invalid or empty after potential transformation. Skipping.", "FaultBufferTool")
                 return False

            # --- Determine Buffer Type and Parameters ---
            segments = 5  # Default segments for buffer function
            buffer_ratio = 1.0  # Default for symmetric buffers (FW:HW = 1:1)
            dip_direction = None
            is_asymmetric = False
            fault_type_str = "Symmetric" # Default buffer type description

            available_fields_lower = [f.name().lower() for f in feature.fields()]

            # Check Fault Type Selection (Uniform or From Shapefile)
            if self.dlg.UniformFaultTypeRadioButton.isChecked():
                if self.dlg.StrikeslipFaultRadioButton.isChecked():
                    fault_type_str = "Strike-slip (Uniform)"
                    is_asymmetric = False
                elif self.dlg.NormalFaultRadioButton.isChecked():
                    fault_type_str = "Normal (Uniform)"
                    is_asymmetric = True
                    buffer_ratio = 4.0 # FW:HW = 1:4 -> HW is 4 times FW -> ratio HW/FW = 4
                elif self.dlg.ReverseFaultRadioButton.isChecked():
                    fault_type_str = "Reverse (Uniform)"
                    is_asymmetric = True
                    buffer_ratio = 2.0 # FW:HW = 1:2 -> HW is 2 times FW -> ratio HW/FW = 2
            elif self.dlg.FromShapefileFaultTypeRadioButton.isChecked():
                if 'fault_type' in available_fields_lower:
                    fault_code_val = feature['Fault_type'] # Assuming original name 'Fault_type'
                    if isinstance(fault_code_val, str):
                        fault_code = fault_code_val.strip().upper()
                        if fault_code == 'S':
                            fault_type_str = "Strike-slip (Shapefile)"
                            is_asymmetric = False
                        elif fault_code == 'N':
                            fault_type_str = "Normal (Shapefile)"
                            is_asymmetric = True
                            buffer_ratio = 4.0
                        elif fault_code == 'R':
                            fault_type_str = "Reverse (Shapefile)"
                            is_asymmetric = True
                            buffer_ratio = 2.0
                        else:
                            fault_type_str = f"Strike-slip (Invalid Shapefile Type: '{fault_code_val}')"
                            is_asymmetric = False # Fallback to symmetric
                            QgsMessageLog.logMessage(f"Feature {fid}: Invalid Fault_type '{fault_code_val}'. Defaulting to Symmetric.", "FaultBufferTool")
                    else:
                         fault_type_str = f"Strike-slip (Missing/Invalid Shapefile Type)"
                         is_asymmetric = False # Fallback
                         QgsMessageLog.logMessage(f"Feature {fid}: Missing or non-string Fault_type attribute. Defaulting to Symmetric.", "FaultBufferTool")
                else:
                    fault_type_str = "Strike-slip (Missing Shapefile Field)"
                    is_asymmetric = False # Fallback
                    QgsMessageLog.logMessage(f"Feature {fid}: Missing 'Fault_type' field. Defaulting to Symmetric.", "FaultBufferTool")

            # Get Dip Direction ONLY if asymmetry is needed
            if is_asymmetric:
                if 'dip_direct' in available_fields_lower:
                    dip_dir_val = feature['Dip_direct'] # Assuming original name 'Dip_direct'
                    if isinstance(dip_dir_val, str) and dip_dir_val.strip():
                        dip_dir_candidate = dip_dir_val.strip().upper()
                        valid_directions = ['N', 'S', 'E', 'W', 'NE', 'NW', 'SE', 'SW']
                        if dip_dir_candidate in valid_directions:
                            dip_direction = dip_dir_candidate # Store the valid direction
                        else:
                            QgsMessageLog.logMessage(f"Feature {fid}: Invalid Dip_direct value '{dip_dir_val}'. Falling back to symmetric buffer.", "FaultBufferTool")
                            is_asymmetric = False # Fallback
                            fault_type_str += " (Symmetric Fallback - Invalid Dip)"
                    else:
                        QgsMessageLog.logMessage(f"Feature {fid}: Empty or non-string Dip_direct value '{dip_dir_val}'. Falling back to symmetric buffer.", "FaultBufferTool")
                        is_asymmetric = False # Fallback
                        fault_type_str += " (Symmetric Fallback - Empty/Invalid Dip)"
                else:
                    # This should have been caught by validate_required_fields
                    QgsMessageLog.logMessage(f"Feature {fid}: Missing 'Dip_direct' field required for asymmetric buffer. Falling back to symmetric.", "FaultBufferTool")
                    is_asymmetric = False # Fallback
                    fault_type_str += " (Symmetric Fallback - Missing Dip Field)"

            # --- Create Buffer Geometry ---
            buffer_geom = None
            if is_asymmetric and dip_direction:
                QgsMessageLog.logMessage(f"Feature {fid}: Attempting asymmetric buffer: dist={distance}, ratio={buffer_ratio}, dip={dip_direction}", "FaultBufferTool")
                buffer_geom = self.create_asymmetric_buffer(
                    geometry, distance, dip_direction, utm_crs, segments, buffer_ratio
                )
                if not buffer_geom or buffer_geom.isEmpty():
                    QgsMessageLog.logMessage(f"Feature {fid}: Asymmetric buffer creation failed. Falling back to symmetric.", "FaultBufferTool")
                    fault_type_str += " (Symmetric Fallback - Asym Creation Failed)"
                    # Reset flags for symmetric buffer creation below
                    is_asymmetric = False
                    dip_direction = None
                    buffer_geom = None # Ensure it's None so symmetric buffer is created
                else:
                    QgsMessageLog.logMessage(f"Feature {fid}: Asymmetric buffer created.", "FaultBufferTool")
                    fault_type_str += f" (Asymmetric Ratio={buffer_ratio:.2f})" # Add ratio info

            # Create symmetric buffer if needed (not asymmetric or asymmetric failed)
            if not buffer_geom:
                QgsMessageLog.logMessage(f"Feature {fid}: Creating symmetric buffer, distance={distance}", "FaultBufferTool")
                buffer_geom = geometry.buffer(distance, segments)
                if not buffer_geom or buffer_geom.isEmpty():
                    QgsMessageLog.logMessage(f"Feature {fid}: Symmetric buffer creation failed. Skipping feature.", "FaultBufferTool")
                    return False # Cannot proceed if even symmetric fails

            # Validate final buffer geometry
            if not buffer_geom or buffer_geom.isEmpty() or not buffer_geom.isGeosValid():
                QgsMessageLog.logMessage(f"Feature {fid}: Final buffer geometry is invalid or empty. Skipping.", "FaultBufferTool")
                return False

            # --- Create Output Feature ---
            buffer_feature = QgsFeature(buffer_layer.fields())
            buffer_feature.setGeometry(buffer_geom)

            # Copy attributes from original feature, checking if field exists in output
            buffer_field_names = [f.name() for f in buffer_layer.fields()]
            for field in input_layer.fields():
                field_name = field.name()
                if field_name in buffer_field_names and field_name in feature.attributes(): # Check input feature has the attribute too
                     try:
                         buffer_feature.setAttribute(field_name, feature[field_name])
                     except KeyError:
                          # This might happen if the input feature schema differs slightly from layer schema
                          QgsMessageLog.logMessage(f"Feature {fid}: Could not copy attribute '{field_name}'. Field might be missing in this specific feature.", "FaultBufferTool")


            # Set/Overwrite buffer-specific attributes (check if fields exist)
            if "Buffer_Dist" in buffer_field_names:
                buffer_feature.setAttribute("Buffer_Dist", float(distance)) # Ensure float
            if "Buffer_Type" in buffer_field_names:
                buffer_feature.setAttribute("Buffer_Type", fault_type_str)
            if "Dip_Direction" in buffer_field_names:
                # Store dip direction ONLY if asymmetry was successfully applied
                buffer_feature.setAttribute("Dip_Direction", dip_direction if is_asymmetric and dip_direction else None)
            # Consider adding original_id if helpful for tracing back
            # if "original_id" in buffer_field_names:
            #     buffer_feature.setAttribute("original_id", fid)


            # Add feature to buffer layer
            if not buffer_layer.dataProvider().addFeature(buffer_feature):
                QgsMessageLog.logMessage(f"Feature {fid}: Failed to add buffered feature to the output layer.", "FaultBufferTool")
                return False

            return True # Success

        except Exception as e:
            fid_str = f"feature {feature.id()}" if feature else "unknown feature"
            QgsMessageLog.logMessage(f"Error in create_buffer_for_feature for {fid_str}: {str(e)}", "FaultBufferTool")
            import traceback
            QgsMessageLog.logMessage(f"Traceback: {traceback.format_exc()}", "FaultBufferTool")
            return False

    def run(self):
        """Run method that performs all the real work"""
        # Create the dialog if it's the first time
        if self.first_start:
            self.first_start = False
            self.dlg = FaultBufferToolDialog()
            self.dlg.setupUi(self.dlg) # Setup the UI elements from the .ui file

            # --- Setup UI Connections and Initial State ---
            self.setupDialogConnections() # Connect signals to slots
            self.update_ui_state() # Set the initial enabled/disabled states

            # Configure the file widget
            self.dlg.mQgsFileWidget.setStorageMode(QgsFileWidget.SaveFile)
            self.dlg.mQgsFileWidget.setFilter("ESRI Shapefile (*.shp)") # Standard filter name
            self.dlg.mQgsFileWidget.setFilePath("")

        # Clear previous output path if reusing dialog
        self.dlg.mQgsFileWidget.setFilePath("")

        # Show the dialog
        self.dlg.show()

        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # --- Start Processing ---
            try:
                # Get input layer
                input_layer = self.dlg.mMapLayerComboBox.currentLayer()
                if not input_layer or not isinstance(input_layer, QgsVectorLayer):
                    QMessageBox.critical(self.dlg, "Error", "Please select a valid vector layer.")
                    return

                # Get output path
                output_path = self.dlg.mQgsFileWidget.filePath()
                if not output_path:
                    QMessageBox.critical(self.dlg, "Error", "Please specify an output shapefile location.")
                    return
                if not output_path.lower().endswith('.shp'):
                    output_path += '.shp'

                # --- Validate Selections and Required Fields ---
                is_valid, error_message = self.validate_required_fields(input_layer)
                if not is_valid:
                    QMessageBox.critical(self.dlg, "Missing Field Error", error_message)
                    return

                # Validate specific inputs based on mode
                if self.dlg.geologicJudgementRadioButton.isChecked() and self.dlg.inputWidth.isChecked():
                    try:
                        width = float(self.dlg.widthinput.text())
                        if width <= 0:
                            QMessageBox.critical(self.dlg, "Input Error", "Please enter a positive number for the buffer width.")
                            return
                    except ValueError:
                         QMessageBox.critical(self.dlg, "Input Error", "Please enter a valid number for the buffer width.")
                         return

                # --- CRS Handling ---
                source_crs = input_layer.crs()
                transform = None
                utm_crs = None

                if source_crs.isGeographic():
                    try:
                        center_point = input_layer.extent().center()
                        utm_crs = self.get_utm_crs(center_point.x(), center_point.y())
                        if not utm_crs.isValid():
                             raise ValueError(f"Could not determine a valid UTM CRS for center {center_point.x()}, {center_point.y()}")
                        transform = QgsCoordinateTransform(source_crs, utm_crs, QgsProject.instance().transformContext())
                        QgsMessageLog.logMessage(f"Source CRS is geographic ({source_crs.authid()}). Using UTM CRS: {utm_crs.authid()}", "FaultBufferTool")
                    except Exception as e:
                         QMessageBox.critical(self.dlg, "CRS Error", f"Could not determine projected CRS for buffering: {e}")
                         return
                else:
                    utm_crs = source_crs # Already projected
                    QgsMessageLog.logMessage(f"Source CRS is projected: {source_crs.authid()}. Using it for buffering.", "FaultBufferTool")

                if not utm_crs or not utm_crs.isValid():
                     QMessageBox.critical(self.dlg, "CRS Error", "Could not establish a valid projected CRS for buffering.")
                     return

                # --- Prepare Output Layer ---
                buffer_layer = QgsVectorLayer(f"Polygon?crs={utm_crs.authid()}", "temp_buffers", "memory")
                buffer_provider = buffer_layer.dataProvider()

                # Copy fields from input layer + add buffer-specific fields
                input_fields = input_layer.fields()
                fields_to_add = list(input_fields) # Start with a copy of input fields
                fields_to_add.extend([
                    QgsField("Buffer_Dist", QVariant.Double, len=20, prec=3), # Increased precision maybe
                    QgsField("Buffer_Type", QVariant.String, len=80), # Longer string for detailed type
                    QgsField("Dip_Direction", QVariant.String, len=10)
                    # QgsField("original_id", QVariant.Int) # Optional tracking field
                ])
                buffer_provider.addAttributes(fields_to_add)
                buffer_layer.updateFields()
                QgsMessageLog.logMessage("Output buffer layer fields initialized.", "FaultBufferTool")

                # --- Process Features ---
                total_features = input_layer.featureCount()
                processed_count = 0
                failed_count = 0
                skipped_count = 0

                # Start editing session for the memory layer
                buffer_layer.startEditing()

                for feature in input_layer.getFeatures():
                    buffer_distance = 0
                    # Determine buffer distance based on mode
                    if self.dlg.geologicJudgementRadioButton.isChecked():
                        buffer_distance = self.get_buffer_distance_for_feature(feature)
                        if buffer_distance <= 0:
                            # Message already logged in get_buffer_distance_for_feature
                            skipped_count += 1
                            continue # Skip feature if distance is invalid/zero
                    elif self.dlg.generalUncertaintyRadioButton.isChecked() or self.dlg.uncertaintyWithRankingRadioButton.isChecked():
                        buffer_distance = self.get_uncertainty_distance(feature)
                        if buffer_distance <= 0:
                             QgsMessageLog.logMessage(f"Feature {feature.id()}: Skipping due to zero or negative uncertainty distance ({buffer_distance}).", "FaultBufferTool")
                             skipped_count += 1
                             continue # Skip feature
                    else:
                         # Should not happen if UI is set up correctly
                         QgsMessageLog.logMessage(f"Feature {feature.id()}: No valid mode selected. Skipping.", "FaultBufferTool")
                         skipped_count += 1
                         continue

                    # Create buffer for the feature
                    success = self.create_buffer_for_feature(
                        feature, buffer_layer, buffer_distance, input_layer,
                        transform, utm_crs, source_crs
                    )

                    if success:
                        processed_count += 1
                    else:
                        failed_count += 1
                        # Error message logged within create_buffer_for_feature

                    # Optional: Update progress bar if added to UI
                    # self.iface.mainWindow().statusBar().showMessage(f"Processed {processed_count}/{total_features} features...")

                # Commit changes to the memory layer
                if not buffer_layer.commitChanges():
                     QgsMessageLog.logMessage("Error committing changes to the memory buffer layer.", "FaultBufferTool")
                     # Attempt rollback? Might not be necessary for memory layer.
                     buffer_layer.rollBack() # Roll back just in case
                     QMessageBox.critical(self.dlg, "Error", "Failed to commit features to the temporary buffer layer. Check logs.")
                     return


                QgsMessageLog.logMessage(f"Processing complete. Successfully buffered: {processed_count}, Failed: {failed_count}, Skipped: {skipped_count}", "FaultBufferTool")

                if processed_count == 0:
                     QMessageBox.warning(self.dlg, "No Buffers Created", "No features were successfully buffered. Please check the input data, selections, and QGIS Message Log for details.")
                     return # Don't save an empty layer

                # --- Save Output Layer ---
                options = QgsVectorFileWriter.SaveVectorOptions()
                options.driverName = "ESRI Shapefile"
                options.fileEncoding = "UTF-8"
                # Important: If we transformed, save in the original CRS unless user wants projected
                # For simplicity now, saving in the projected CRS (utm_crs) used for buffering
                # To save back in original: options.ct = QgsCoordinateTransform(utm_crs, source_crs, ...)
                options.layerName = os.path.splitext(os.path.basename(output_path))[0]

                write_error, write_error_message = QgsVectorFileWriter.writeAsVectorFormatV3(
                    buffer_layer,
                    output_path,
                    QgsProject.instance().transformContext(), # Use project context
                    options
                )

                if write_error != QgsVectorFileWriter.NoError:
                    QMessageBox.critical(self.dlg, "Save Error", f"Failed to save buffer layer to:\n{output_path}\nError: {write_error_message}")
                    return

                # --- Add Layer to Map ---
                output_layer_name = options.layerName
                result_layer = QgsVectorLayer(output_path, output_layer_name, "ogr")
                if not result_layer.isValid():
                     QMessageBox.critical(self.dlg, "Load Error", f"Failed to load the created buffer layer:\n{output_path}")
                     return

                # Apply style
                style_path = os.path.join(os.path.dirname(__file__), "style_buffer.qml")
                if os.path.exists(style_path):
                    result_layer.loadNamedStyle(style_path)
                    QgsMessageLog.logMessage("Applied style from style_buffer.qml", "FaultBufferTool")
                else:
                     QgsMessageLog.logMessage("Warning: style_buffer.qml not found. Using default style.", "FaultBufferTool")


                # Add to project below input layer
                project = QgsProject.instance()
                root = project.layerTreeRoot()
                input_node = root.findLayer(input_layer.id())
                if input_node:
                     # Insert below the input layer's node
                     parent_node = input_node.parent()
                     if parent_node:
                          insert_index = parent_node.children().index(input_node) + 1
                          parent_node.insertLayer(insert_index, result_layer)
                     else: # input node is top-level
                          insert_index = root.children().index(input_node) + 1
                          root.insertLayer(insert_index, result_layer)
                else:
                     # Fallback: just add to top level
                     project.addMapLayer(result_layer)


                result_layer.triggerRepaint() # Refresh map canvas
                self.iface.layerTreeView().refreshLayerSymbology(result_layer.id()) # Refresh legend

                QMessageBox.information(self.dlg, "Success",
                    f"Buffer layer created and saved successfully:\n{output_path}\n\nProcessed: {processed_count}\nFailed/Skipped: {failed_count + skipped_count}")

            except Exception as e:
                QgsMessageLog.logMessage(f"Unexpected error during processing: {str(e)}", "FaultBufferTool", level=Qgis.Critical)
                import traceback
                QgsMessageLog.logMessage(f"Traceback: {traceback.format_exc()}", "FaultBufferTool", level=Qgis.Critical)
                QMessageBox.critical(self.dlg, "Critical Error", f"An unexpected error occurred: {str(e)}\n\nPlease check the QGIS Message Log (Plugins -> FaultBufferTool) for details.")
                # Clean up temp layer? Not strictly necessary for memory layer.
                return